<p>Realtime Database is one of the most important features of App development nowadays. It is required to handle data synchronization between client and server. It’s challenging to create a mobile app that allows the user to access data from any device. We need to create API or web services to handle this. All of these challenges can be fulfilled by using <code class="highlighter-rouge">Firebase Realtime Database</code>.</p>

<h3 id="firebase-realtime-database">Firebase Realtime Database</h3>

<p><code class="highlighter-rouge">Firebase Realtime Database</code> is cloud hosted NoSQL(Non-Relational) database. It stores data in JSON form(not in tabular form). It’s called Realtime due to synchronizing in real-time to all connected devices. All platforms app share one database instance and automatically receives updates with latest data. <code class="highlighter-rouge">Firebase Realtime Database</code> allows nesting data up to 32 levels deep. The developer can allow automatically database backup also.</p>

<h3 id="key-feature-of-firebase-realtime-database">Key Feature of Firebase Realtime Database</h3>

<ul>
  <li>
    <p>Realtime: Despite typical HTTP requests, the <code class="highlighter-rouge">Firebase Realtime Database</code> uses data synchronization—every time data changes, all connected device receives that update within milliseconds.</p>
  </li>
  <li>
    <p>Offline: Firebase apps remain responsive even when offline because the Firebase Realtime Database SDK persists your data to disk. Once connectivity is reestablished, the client device receives any changes it missed.</p>
  </li>
  <li>
    <p>Accessible from Client Devices: Firebase Database can access directly from any client device. There is no need for any server.</p>
  </li>
</ul>

<h3 id="rules">Rules</h3>

<p>The Realtime Database API is designed to only allow operations that can be executed quickly. Firebase Database Rules defines which user can read or write to the database. These rules are automatically applied to all query automatically. By default, rules are set to allow only authenticated users full read and write access to the database. There is four rule type for firebase.</p>
<ul>
  <li>
    <p>read: allow the user to read.</p>
  </li>
  <li>
    <p>write: allow the user to write.</p>
  </li>
  <li>
    <p>validate: allows you to apply validation logic using the same expressions used for .read and .write rules.</p>
  </li>
  <li>
    <p>indexOn: to specify ordering and querying data.</p>
  </li>
</ul>

<h3 id="enable-offline-capabilities">Enable Offline Capabilities</h3>

<p>Firebase app automatically handles the temporary network issue. Firebase uses cached data for better user experiences. It persists user data to disk. Cached data is available while offline.
Developer can enable disk persistence with just one line of code.</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>FirebaseDatabase.getInstance().setPersistenceEnabled(true);
</code></pre>
</div>

<h3 id="performaning-firebase-realtime-database-operations">Performaning Firebase Realtime Database Operations</h3>

<p>This is my firebase database structure.
<img src="/static/firebase_database.png" alt="Drawing" style="width: 600px;"></p>

<p>To perform any operations on database, developer needs to get the reference of database</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>private DatabaseReference mDatabase;
mDatabase = FirebaseDatabase.getInstance().getReference();
</code></pre>
</div>
<p>It returns the reference of top node. If developer needs the reference of a perticular node then developer have to pass the node . The below code will return the reference of  <code class="highlighter-rouge">chat</code> node.</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>mDatabase = FirebaseDatabase.getInstance().getReference("chat");
</code></pre>
</div>

<h4 id="write-data-to-firebase">Write Data to Firebase</h4>

<p>We will store the chat object to the database. For this first, we have to create a chat model class.</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>public class ChatDTO {

    private String id;
    private String userName;
    private String message;

    public ChatDTO() {
    }

    public ChatDTO(String id, String userName, String message) {
        this.id = id;
        this.userName = userName;
        this.message = message;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre>
</div>

<p>As every chat needs a unique Id, you can generate one by calling push() method which creates an empty node with a unique key. Then get the reference to <code class="highlighter-rouge">chat</code> node using child() method. Then use <code class="highlighter-rouge">setValue()</code> method to store the chat data. By the below code a new chat object is stored with unique key value.</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>String id = mDatabaseReference.push().getKey();
ChatDTO chatDTO = new ChatDTO(id, name, message);
mDatabaseReference.child(id).setValue(chatDTO);
</code></pre>
</div>

<h4 id="read-data-from-firebase">Read Data from Firebase</h4>

<p>To read the data, you need to attach the <code class="highlighter-rouge">ValueEventListener()</code> to the database reference. This event will be triggered whenever there is a change in data in real-time. In <code class="highlighter-rouge">onDataChange()</code> you can perform the desired operations onto new data.</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>mDatabaseReference.addValueEventListener(valueEventListener);
ValueEventListener valueEventListener = new ValueEventListener() {
        @Override
        public void onDataChange(DataSnapshot dataSnapshot) {
          mChatDTOs.clear();
          Iterable&lt;DataSnapshot&gt; children =  dataSnapshot.getChildren();
            for (DataSnapshot snapShot : children){
                ChatDTO chatDTO =  snapShot.getValue(ChatDTO.class);
            }
        }

        @Override
        public void onCancelled(DatabaseError databaseError) {
            Log.e("error", databaseError.getMessage());
        }
    };
</code></pre>
</div>

<h4 id="update-data-form-firebase">Update Data form Firebase</h4>

<p>To update data, you can use the same <code class="highlighter-rouge">setValue()</code> method by passing new value. You can also use <code class="highlighter-rouge">updateChildren()</code> by passing the path to update data without disturbing other child nodes data.</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>mDatabaseReference.child(id).child("userName").setValue(newUserName);
</code></pre>
</div>
<p>where id is the node which have to update.</p>

<h3 id="delete-data-form-firebase">Delete Data form Firebase</h3>

<p>To delete data, you can simply call <code class="highlighter-rouge">removeValue()</code> method on to database reference. You can also pass null to <code class="highlighter-rouge">setValue()</code> method which does the same delete operation.</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>mDatabaseReference.child(id).setValue(null);
</code></pre>
</div>
<p>Where <code class="highlighter-rouge">id</code> is the node which has to be deleted.</p>

<h4 id="references">References</h4>
<p>https://firebase.googleblog.com/2016/07/have-you-met-realtime-database.html</p>
